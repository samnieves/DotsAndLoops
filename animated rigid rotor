import numpy as np
from matplotlib import pyplot as plt
from matplotlib import animation

fig = plt.figure()
ax = plt.axes(xlim=(0, 2*np.pi), ylim=(-0.1, 0.1))
line, = ax.plot([], [], lw=2)

rad = np.linspace(0,np.pi*2,100)



def Gauss_Packet(phi, phi0, sig, k0):
    ci = 0.+1j
    pre = 1./(sig*np.sqrt(2.*np.pi))
    psi_x = pre*np.exp(-0.5*((phi-phi0)/sig)**2)*np.exp(ci*l0*phi)
    return psi_x

def rigid_eigenfunc (phi, ml):
   ci = 0. + 1j
   return (1/np.sqrt(np.pi*2)*np.exp(ci*ml*phi))


def rigid_energy (ml):
    return ((ml*ml))/(2*mu*(r*r))

def rigid_time (ml, t):
    ci = 0. + 1j
    return np.exp(-ci*rigid_energy(ml)*t)

def FourierAnalysis(phi, Psi, ml):
    cn = np.zeros(len(ml),dtype=complex)
    dphi = phi[1]-phi[0]
    for i in range (0,len(cn)):

      som = 0+0j
      psi_i = rigid_eigenfunc (phi, ml[i])

      for j in range (0, len(phi)):
        som = som + psi_i[j]*Psi[j]*dphi

      cn[i] = som

    return cn



#nt = np.linspace(1,200,200)

#p1 = rigid_eigenfunc(rad, 1)
xt = np.linspace(0, 200, 200)
P1 = rigid_energy(1)*rigid_eigenfunc(rad, 1)
sig = 15.    
nt=np.linspace(-5, 5, 11)
phi0 = 200
m1 = 1
m2 = 1
mu = (m1*m2)/(m1+m2)
r = 1.39839789
k0 = 0
l0 = 0
phi = np.linspace(0, 2*np.pi, 200)
Psi = Gauss_Packet(xt, phi0, sig, k0)
cn = FourierAnalysis(xt, Psi, nt)
#y=eigenfunc(phi, ml)*energyfunc(ml)
#x= np.real(r*np.cos(phi))
#y= np.real(r*np.sin(phi))



#### Static plot
#plt.plot(rad, np.real(P1))
#plt.show()
#print(P1)

def init():
    line.set_data([], [])
    return line,

# animation function.  This is called sequentially to generate the animation
def animate(i):
    
    ### Once PIB_Func and PIB_En are defined, the following
    ### code can be used to plot the time-evolution of an energy eigenfunction

    ### Define x-grid - this will be for a particle in a box of length L=30 atomic units (Bohr radii)
    ### We will represent the function with 1000 grid points (dx = 30/1000)
    
    x = np.linspace(0, 2*np.pi, 100)

    m = np.linspace(-5, 5, 11)
    ### Imaginary unit i
    ci = 0.+1j
    psi_t = np.zeros(len(x),dtype=complex)
    #psi = PIB_Func(x, 2, L)
    #ft = PIB_Time(2, L, i)
    #psi30 = PIB_Func(x, 30, L)
    #ft30 = PIB_Time(30, L, 4*i)
    #psi20 = PIB_Func(x, 40, L)
    #ft20 = PIB_Time(40, L, 4*i)
    #psi_t = psi30*ft30 + psi20*ft20
    
    for j in range(0,len(m)):
      p1 = rigid_eigenfunc(rad, m[j])
      ft  = rigid_time(m[j], 4*i)
      psi_t = psi_t + cn[j]*p1*ft
   
    psi_t_star = np.conj(psi_t)

    y = np.real(psi_t)
    z = np.imag(psi_t)
    p = np.real(psi_t_star * psi_t)
    line.set_data(x, y)
    return line,


anim = animation.FuncAnimation(fig, animate, init_func=init,
                               frames=10000, interval=100, blit=True)
### uncomment to save animation as mp4 
#anim.save('pib_wp.mp4', fps=20, extra_args=['-vcodec', 'libx264'])
#plt.show()
